// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/OhMinsSup/story-server/ent/migrate"
	"github.com/google/uuid"

	"github.com/OhMinsSup/story-server/ent/authtoken"
	"github.com/OhMinsSup/story-server/ent/emailauth"
	"github.com/OhMinsSup/story-server/ent/socialaccount"
	"github.com/OhMinsSup/story-server/ent/user"
	"github.com/OhMinsSup/story-server/ent/usermeta"
	"github.com/OhMinsSup/story-server/ent/userprofile"
	"github.com/OhMinsSup/story-server/ent/velogconfig"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthToken is the client for interacting with the AuthToken builders.
	AuthToken *AuthTokenClient
	// EmailAuth is the client for interacting with the EmailAuth builders.
	EmailAuth *EmailAuthClient
	// SocialAccount is the client for interacting with the SocialAccount builders.
	SocialAccount *SocialAccountClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserMeta is the client for interacting with the UserMeta builders.
	UserMeta *UserMetaClient
	// UserProfile is the client for interacting with the UserProfile builders.
	UserProfile *UserProfileClient
	// VelogConfig is the client for interacting with the VelogConfig builders.
	VelogConfig *VelogConfigClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthToken = NewAuthTokenClient(c.config)
	c.EmailAuth = NewEmailAuthClient(c.config)
	c.SocialAccount = NewSocialAccountClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserMeta = NewUserMetaClient(c.config)
	c.UserProfile = NewUserProfileClient(c.config)
	c.VelogConfig = NewVelogConfigClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		AuthToken:     NewAuthTokenClient(cfg),
		EmailAuth:     NewEmailAuthClient(cfg),
		SocialAccount: NewSocialAccountClient(cfg),
		User:          NewUserClient(cfg),
		UserMeta:      NewUserMetaClient(cfg),
		UserProfile:   NewUserProfileClient(cfg),
		VelogConfig:   NewVelogConfigClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:        cfg,
		AuthToken:     NewAuthTokenClient(cfg),
		EmailAuth:     NewEmailAuthClient(cfg),
		SocialAccount: NewSocialAccountClient(cfg),
		User:          NewUserClient(cfg),
		UserMeta:      NewUserMetaClient(cfg),
		UserProfile:   NewUserProfileClient(cfg),
		VelogConfig:   NewVelogConfigClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthToken.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.AuthToken.Use(hooks...)
	c.EmailAuth.Use(hooks...)
	c.SocialAccount.Use(hooks...)
	c.User.Use(hooks...)
	c.UserMeta.Use(hooks...)
	c.UserProfile.Use(hooks...)
	c.VelogConfig.Use(hooks...)
}

// AuthTokenClient is a client for the AuthToken schema.
type AuthTokenClient struct {
	config
}

// NewAuthTokenClient returns a client for the AuthToken from the given config.
func NewAuthTokenClient(c config) *AuthTokenClient {
	return &AuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtoken.Hooks(f(g(h())))`.
func (c *AuthTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthToken = append(c.hooks.AuthToken, hooks...)
}

// Create returns a create builder for AuthToken.
func (c *AuthTokenClient) Create() *AuthTokenCreate {
	mutation := newAuthTokenMutation(c.config, OpCreate)
	return &AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthToken entities.
func (c *AuthTokenClient) CreateBulk(builders ...*AuthTokenCreate) *AuthTokenCreateBulk {
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthToken.
func (c *AuthTokenClient) Update() *AuthTokenUpdate {
	mutation := newAuthTokenMutation(c.config, OpUpdate)
	return &AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTokenClient) UpdateOne(at *AuthToken) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthToken(at))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTokenClient) UpdateOneID(id uuid.UUID) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthTokenID(id))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthToken.
func (c *AuthTokenClient) Delete() *AuthTokenDelete {
	mutation := newAuthTokenMutation(c.config, OpDelete)
	return &AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthTokenClient) DeleteOne(at *AuthToken) *AuthTokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthTokenClient) DeleteOneID(id uuid.UUID) *AuthTokenDeleteOne {
	builder := c.Delete().Where(authtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTokenDeleteOne{builder}
}

// Query returns a query builder for AuthToken.
func (c *AuthTokenClient) Query() *AuthTokenQuery {
	return &AuthTokenQuery{config: c.config}
}

// Get returns a AuthToken entity by its id.
func (c *AuthTokenClient) Get(ctx context.Context, id uuid.UUID) (*AuthToken, error) {
	return c.Query().Where(authtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTokenClient) GetX(ctx context.Context, id uuid.UUID) *AuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthTokenClient) Hooks() []Hook {
	return c.hooks.AuthToken
}

// EmailAuthClient is a client for the EmailAuth schema.
type EmailAuthClient struct {
	config
}

// NewEmailAuthClient returns a client for the EmailAuth from the given config.
func NewEmailAuthClient(c config) *EmailAuthClient {
	return &EmailAuthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailauth.Hooks(f(g(h())))`.
func (c *EmailAuthClient) Use(hooks ...Hook) {
	c.hooks.EmailAuth = append(c.hooks.EmailAuth, hooks...)
}

// Create returns a create builder for EmailAuth.
func (c *EmailAuthClient) Create() *EmailAuthCreate {
	mutation := newEmailAuthMutation(c.config, OpCreate)
	return &EmailAuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailAuth entities.
func (c *EmailAuthClient) CreateBulk(builders ...*EmailAuthCreate) *EmailAuthCreateBulk {
	return &EmailAuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailAuth.
func (c *EmailAuthClient) Update() *EmailAuthUpdate {
	mutation := newEmailAuthMutation(c.config, OpUpdate)
	return &EmailAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailAuthClient) UpdateOne(ea *EmailAuth) *EmailAuthUpdateOne {
	mutation := newEmailAuthMutation(c.config, OpUpdateOne, withEmailAuth(ea))
	return &EmailAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailAuthClient) UpdateOneID(id uuid.UUID) *EmailAuthUpdateOne {
	mutation := newEmailAuthMutation(c.config, OpUpdateOne, withEmailAuthID(id))
	return &EmailAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailAuth.
func (c *EmailAuthClient) Delete() *EmailAuthDelete {
	mutation := newEmailAuthMutation(c.config, OpDelete)
	return &EmailAuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EmailAuthClient) DeleteOne(ea *EmailAuth) *EmailAuthDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EmailAuthClient) DeleteOneID(id uuid.UUID) *EmailAuthDeleteOne {
	builder := c.Delete().Where(emailauth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailAuthDeleteOne{builder}
}

// Query returns a query builder for EmailAuth.
func (c *EmailAuthClient) Query() *EmailAuthQuery {
	return &EmailAuthQuery{config: c.config}
}

// Get returns a EmailAuth entity by its id.
func (c *EmailAuthClient) Get(ctx context.Context, id uuid.UUID) (*EmailAuth, error) {
	return c.Query().Where(emailauth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailAuthClient) GetX(ctx context.Context, id uuid.UUID) *EmailAuth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EmailAuthClient) Hooks() []Hook {
	return c.hooks.EmailAuth
}

// SocialAccountClient is a client for the SocialAccount schema.
type SocialAccountClient struct {
	config
}

// NewSocialAccountClient returns a client for the SocialAccount from the given config.
func NewSocialAccountClient(c config) *SocialAccountClient {
	return &SocialAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `socialaccount.Hooks(f(g(h())))`.
func (c *SocialAccountClient) Use(hooks ...Hook) {
	c.hooks.SocialAccount = append(c.hooks.SocialAccount, hooks...)
}

// Create returns a create builder for SocialAccount.
func (c *SocialAccountClient) Create() *SocialAccountCreate {
	mutation := newSocialAccountMutation(c.config, OpCreate)
	return &SocialAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SocialAccount entities.
func (c *SocialAccountClient) CreateBulk(builders ...*SocialAccountCreate) *SocialAccountCreateBulk {
	return &SocialAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SocialAccount.
func (c *SocialAccountClient) Update() *SocialAccountUpdate {
	mutation := newSocialAccountMutation(c.config, OpUpdate)
	return &SocialAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SocialAccountClient) UpdateOne(sa *SocialAccount) *SocialAccountUpdateOne {
	mutation := newSocialAccountMutation(c.config, OpUpdateOne, withSocialAccount(sa))
	return &SocialAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SocialAccountClient) UpdateOneID(id uuid.UUID) *SocialAccountUpdateOne {
	mutation := newSocialAccountMutation(c.config, OpUpdateOne, withSocialAccountID(id))
	return &SocialAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SocialAccount.
func (c *SocialAccountClient) Delete() *SocialAccountDelete {
	mutation := newSocialAccountMutation(c.config, OpDelete)
	return &SocialAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SocialAccountClient) DeleteOne(sa *SocialAccount) *SocialAccountDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SocialAccountClient) DeleteOneID(id uuid.UUID) *SocialAccountDeleteOne {
	builder := c.Delete().Where(socialaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SocialAccountDeleteOne{builder}
}

// Query returns a query builder for SocialAccount.
func (c *SocialAccountClient) Query() *SocialAccountQuery {
	return &SocialAccountQuery{config: c.config}
}

// Get returns a SocialAccount entity by its id.
func (c *SocialAccountClient) Get(ctx context.Context, id uuid.UUID) (*SocialAccount, error) {
	return c.Query().Where(socialaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SocialAccountClient) GetX(ctx context.Context, id uuid.UUID) *SocialAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SocialAccount.
func (c *SocialAccountClient) QueryUser(sa *SocialAccount) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(socialaccount.Table, socialaccount.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, socialaccount.UserTable, socialaccount.UserColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SocialAccountClient) Hooks() []Hook {
	return c.hooks.SocialAccount
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserProfile queries the user_profile edge of a User.
func (c *UserClient) QueryUserProfile(u *User) *UserProfileQuery {
	query := &UserProfileQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userprofile.Table, userprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.UserProfileTable, user.UserProfileColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVelogConfig queries the velog_config edge of a User.
func (c *UserClient) QueryVelogConfig(u *User) *VelogConfigQuery {
	query := &VelogConfigQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(velogconfig.Table, velogconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.VelogConfigTable, user.VelogConfigColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserMeta queries the user_meta edge of a User.
func (c *UserClient) QueryUserMeta(u *User) *UserMetaQuery {
	query := &UserMetaQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usermeta.Table, usermeta.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.UserMetaTable, user.UserMetaColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySocialAccount queries the social_account edge of a User.
func (c *UserClient) QuerySocialAccount(u *User) *SocialAccountQuery {
	query := &SocialAccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(socialaccount.Table, socialaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.SocialAccountTable, user.SocialAccountColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// UserMetaClient is a client for the UserMeta schema.
type UserMetaClient struct {
	config
}

// NewUserMetaClient returns a client for the UserMeta from the given config.
func NewUserMetaClient(c config) *UserMetaClient {
	return &UserMetaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usermeta.Hooks(f(g(h())))`.
func (c *UserMetaClient) Use(hooks ...Hook) {
	c.hooks.UserMeta = append(c.hooks.UserMeta, hooks...)
}

// Create returns a create builder for UserMeta.
func (c *UserMetaClient) Create() *UserMetaCreate {
	mutation := newUserMetaMutation(c.config, OpCreate)
	return &UserMetaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserMeta entities.
func (c *UserMetaClient) CreateBulk(builders ...*UserMetaCreate) *UserMetaCreateBulk {
	return &UserMetaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserMeta.
func (c *UserMetaClient) Update() *UserMetaUpdate {
	mutation := newUserMetaMutation(c.config, OpUpdate)
	return &UserMetaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserMetaClient) UpdateOne(um *UserMeta) *UserMetaUpdateOne {
	mutation := newUserMetaMutation(c.config, OpUpdateOne, withUserMeta(um))
	return &UserMetaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserMetaClient) UpdateOneID(id uuid.UUID) *UserMetaUpdateOne {
	mutation := newUserMetaMutation(c.config, OpUpdateOne, withUserMetaID(id))
	return &UserMetaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserMeta.
func (c *UserMetaClient) Delete() *UserMetaDelete {
	mutation := newUserMetaMutation(c.config, OpDelete)
	return &UserMetaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserMetaClient) DeleteOne(um *UserMeta) *UserMetaDeleteOne {
	return c.DeleteOneID(um.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserMetaClient) DeleteOneID(id uuid.UUID) *UserMetaDeleteOne {
	builder := c.Delete().Where(usermeta.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserMetaDeleteOne{builder}
}

// Query returns a query builder for UserMeta.
func (c *UserMetaClient) Query() *UserMetaQuery {
	return &UserMetaQuery{config: c.config}
}

// Get returns a UserMeta entity by its id.
func (c *UserMetaClient) Get(ctx context.Context, id uuid.UUID) (*UserMeta, error) {
	return c.Query().Where(usermeta.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserMetaClient) GetX(ctx context.Context, id uuid.UUID) *UserMeta {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserMeta.
func (c *UserMetaClient) QueryUser(um *UserMeta) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := um.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usermeta.Table, usermeta.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, usermeta.UserTable, usermeta.UserColumn),
		)
		fromV = sqlgraph.Neighbors(um.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserMetaClient) Hooks() []Hook {
	return c.hooks.UserMeta
}

// UserProfileClient is a client for the UserProfile schema.
type UserProfileClient struct {
	config
}

// NewUserProfileClient returns a client for the UserProfile from the given config.
func NewUserProfileClient(c config) *UserProfileClient {
	return &UserProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userprofile.Hooks(f(g(h())))`.
func (c *UserProfileClient) Use(hooks ...Hook) {
	c.hooks.UserProfile = append(c.hooks.UserProfile, hooks...)
}

// Create returns a create builder for UserProfile.
func (c *UserProfileClient) Create() *UserProfileCreate {
	mutation := newUserProfileMutation(c.config, OpCreate)
	return &UserProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProfile entities.
func (c *UserProfileClient) CreateBulk(builders ...*UserProfileCreate) *UserProfileCreateBulk {
	return &UserProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProfile.
func (c *UserProfileClient) Update() *UserProfileUpdate {
	mutation := newUserProfileMutation(c.config, OpUpdate)
	return &UserProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProfileClient) UpdateOne(up *UserProfile) *UserProfileUpdateOne {
	mutation := newUserProfileMutation(c.config, OpUpdateOne, withUserProfile(up))
	return &UserProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProfileClient) UpdateOneID(id uuid.UUID) *UserProfileUpdateOne {
	mutation := newUserProfileMutation(c.config, OpUpdateOne, withUserProfileID(id))
	return &UserProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProfile.
func (c *UserProfileClient) Delete() *UserProfileDelete {
	mutation := newUserProfileMutation(c.config, OpDelete)
	return &UserProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserProfileClient) DeleteOne(up *UserProfile) *UserProfileDeleteOne {
	return c.DeleteOneID(up.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserProfileClient) DeleteOneID(id uuid.UUID) *UserProfileDeleteOne {
	builder := c.Delete().Where(userprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProfileDeleteOne{builder}
}

// Query returns a query builder for UserProfile.
func (c *UserProfileClient) Query() *UserProfileQuery {
	return &UserProfileQuery{config: c.config}
}

// Get returns a UserProfile entity by its id.
func (c *UserProfileClient) Get(ctx context.Context, id uuid.UUID) (*UserProfile, error) {
	return c.Query().Where(userprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProfileClient) GetX(ctx context.Context, id uuid.UUID) *UserProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserProfile.
func (c *UserProfileClient) QueryUser(up *UserProfile) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := up.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprofile.Table, userprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userprofile.UserTable, userprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(up.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProfileClient) Hooks() []Hook {
	return c.hooks.UserProfile
}

// VelogConfigClient is a client for the VelogConfig schema.
type VelogConfigClient struct {
	config
}

// NewVelogConfigClient returns a client for the VelogConfig from the given config.
func NewVelogConfigClient(c config) *VelogConfigClient {
	return &VelogConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `velogconfig.Hooks(f(g(h())))`.
func (c *VelogConfigClient) Use(hooks ...Hook) {
	c.hooks.VelogConfig = append(c.hooks.VelogConfig, hooks...)
}

// Create returns a create builder for VelogConfig.
func (c *VelogConfigClient) Create() *VelogConfigCreate {
	mutation := newVelogConfigMutation(c.config, OpCreate)
	return &VelogConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VelogConfig entities.
func (c *VelogConfigClient) CreateBulk(builders ...*VelogConfigCreate) *VelogConfigCreateBulk {
	return &VelogConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VelogConfig.
func (c *VelogConfigClient) Update() *VelogConfigUpdate {
	mutation := newVelogConfigMutation(c.config, OpUpdate)
	return &VelogConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VelogConfigClient) UpdateOne(vc *VelogConfig) *VelogConfigUpdateOne {
	mutation := newVelogConfigMutation(c.config, OpUpdateOne, withVelogConfig(vc))
	return &VelogConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VelogConfigClient) UpdateOneID(id uuid.UUID) *VelogConfigUpdateOne {
	mutation := newVelogConfigMutation(c.config, OpUpdateOne, withVelogConfigID(id))
	return &VelogConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VelogConfig.
func (c *VelogConfigClient) Delete() *VelogConfigDelete {
	mutation := newVelogConfigMutation(c.config, OpDelete)
	return &VelogConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VelogConfigClient) DeleteOne(vc *VelogConfig) *VelogConfigDeleteOne {
	return c.DeleteOneID(vc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VelogConfigClient) DeleteOneID(id uuid.UUID) *VelogConfigDeleteOne {
	builder := c.Delete().Where(velogconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VelogConfigDeleteOne{builder}
}

// Query returns a query builder for VelogConfig.
func (c *VelogConfigClient) Query() *VelogConfigQuery {
	return &VelogConfigQuery{config: c.config}
}

// Get returns a VelogConfig entity by its id.
func (c *VelogConfigClient) Get(ctx context.Context, id uuid.UUID) (*VelogConfig, error) {
	return c.Query().Where(velogconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VelogConfigClient) GetX(ctx context.Context, id uuid.UUID) *VelogConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VelogConfig.
func (c *VelogConfigClient) QueryUser(vc *VelogConfig) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(velogconfig.Table, velogconfig.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, velogconfig.UserTable, velogconfig.UserColumn),
		)
		fromV = sqlgraph.Neighbors(vc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VelogConfigClient) Hooks() []Hook {
	return c.hooks.VelogConfig
}
